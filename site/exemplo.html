<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <title>Gravity Sort</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans+Extra+Condensed:700|Oxygen+Mono|Source+Sans+Pro:700|Source+Serif+Pro&display=swap">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/script.js"></script>
  </head>
  <body>
    <div class="container">
      <main>

<h1>Gravity Sort</h1>

<h2>De volta à Natureza</h2>

<p>Você já deve ter ouvido falar Dijkstra, um importante cientista da computação, que teve importantes contribuições para o desenvolvimento de algoritmos e linguagens de programação. A partir das ideias de Dijkstra, Rozenberg desenhou o conceito que ficou conhecido como Computação Natural, que se trata de, a partir da observação de estruturas naturais, desenvolver estruturas computacionais.</p>

<p>O Gravity Sort faz parte de uma imensa gama de algoritmos com essas características, já que se baseia na força da gravidade para a sua concepção.</p>

<p>Ok, mas então vamos por fim apresentá-lo</p>

<p>Para entender a ideia podemos imaginar um caminhão carregado de caixa iguais, distribuídas em pilhas de diferentes alturas:</p>

<p class="figure"><img alt="caminhão" src="img/caminhão-1.png" title="caminhão" class="raster"/></p>

<p>Veja: imagine um caminhão com algumas caixas empilhadas dentro dele em uma dada ordem. O caminhão não está lotado, apenas com algumas caixas. Porém, bate um vento forte nele e o caminhão tomba.</p>

<p>Agora imagine que o caminhão está subindo uma ladeira e que essas caixas deslizam em seu interior</p>

<blockquote><p>PERGUNTA: Consegue Imaginar como as caixas ficarão dispostas?</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p class="figure"><img alt="caminhão vetor" src="img/caminhão-2.png" title="caminhão vetor" class="raster"/></p>

<p>Sim, as caixas agora estão organizadas em pilhas crescentes, e adotaram essa composição depois de serem puxadas para traz pela gravidade...daí o nome Gravity Sort</p>

<p class="figure"><img alt="meme_genio" src="img/meme.jpg" title="meme_genio" class="raster"/></p>

<p>Inicialmente esse algoritmo foi pensado para ser demonstrado com um <a href="https://pt.wikipedia.org/wiki/%C3%81baco" target="_blank">ábaco</a>, onde, em inglês, os discos que o compõe são chamados de “bead”, então esse algoritmo também pode ser encontrado como Bead Sort.</p>

<p>Mas enfim, como podemos traduzir essa movimentação que a gravidade proporciona para um código de ordenação?</p>

<p>Primeiro precisamos de um caminhão...</p>

<p>...mas calma, você não precisa criar um caminhão do zero, nos damos ele para você:</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort (input_list):

    # Passo 1: Construir o ábaco com a altura correta    
        # Podemos representar o caminhão como uma lista
        # Onde cada elemento da lista é uma “pilha” e
        # cada &quot;caixa&quot; é representado com uma unidade nesse elemento 
        # iniciamos a lista com zero em cada elemento representando o caminhão vazio

    # Passo 2: Primeiro loop -&gt; Colocar as &quot;caixas&quot; no caminhão
        # Percorremos a lista de valores iniciais e para cada um deles fazemos um novo loop
        # nesse loop interno adicionamos 1 nas N primeiras posições da lista
        # isso funciona como colocar empilhar as caixas em diferentes colunas.

    #Passo 3: </code></pre>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<blockquote><p>Resto do handout anterior. Não será usado. </p></blockquote>

<pre class="prettybox"><code class="prettyprint">def gravity_sort(input_list):

    return_list = []

    transposed_list = [0] * max(input_list)

    for num in input_list:
        transposed_list[:num] = [n + 1 for n in transposed_list[:num]]

    for _ in input_list:
        return_list.append(sum(n &gt; 0 for n in transposed_list))
        transposed_list = [n - 1 for n in transposed_list]

    return return_list</code></pre>

<p>Vamos destrinchar o que está acontecendo aqui. Como dissemos, não faremos uma operação <em>inplace</em>, mas sim retornaremos uma nova lista ordenada após a operação do Gravity Sort. Por isso, chamamos <code class="prettybox prettyprint">return_list = []</code> e inicializamos uma lista transporta <code class="prettybox prettyprint">transposed_list = [0] * max(input_list)</code> que é tão alta quanto o maior valor existente na lista. Isso é para podermos simular o tal do ábaco.</p>

<p>Nessa implementação em software, temos dois loops <code class="prettybox prettyprint">for</code>. Vamos analisar um por um.</p>

<p>No primeiro <code class="prettybox prettyprint">for</code>, </p>

<pre class="prettybox"><code class="prettyprint">for num in input_list:
    transposed_list[:num] = [n + 1 for n in transposed_list[:num]]</code></pre>

<p>estamos vendo para cada elemento da lista de entrada (cada coluna do ábaco), estamos incrementando tantos elementos da <code class="prettybox prettyprint">transposed_list</code> quanto à sua altura. Neste loop, estamos virando o ábaco de lado para que o efeito da gravidade atue. </p>

<p>Agora que os discos caíram, precisamos des-transpor para termos uma lista normal novamente. Para isso, contamos a partir da linha mais baixa dos discos de ábaco caídos e removemos essa linha subtraindo 1 de cada coluna da <code class="prettybox prettyprint">transposed_list</code>. Quando a coluna não é alta o suficiente para a linha atual, seu valor na <code class="prettybox prettyprint">transposed_list</code>será menor que zero. Ou seja:</p>

<pre class="prettybox"><code class="prettyprint">for _ in input_list:
    return_list.append(sum(n &gt; 0 for n in transposed_list))
    transposed_list = [n - 1 for n in transposed_list]</code></pre>

<p>Contando valores maiores que zero é a forma que temos de dizer quantos discos estão na linha mais baixa. Em Python, booleanos podem ser avaliados como inteiros. Ou seja: <code class="prettybox prettyprint">True == 1</code> e <code class="prettybox prettyprint">False == 0</code>. Removemos a linha mais baixa ao subtrair 1 de cada elemento.</p>

<p>Nesta implementação, a lista retornada está ordenada em ordem decrescente. Voltando para a ideia do ábaco, é como se tivéssemos girado o ábaco para a esquerda, ao invés da direita. Isso mostra que podemos ordenar tanto de um lado quanto do outro</p>

<blockquote><p>PERGUNTA: Sabemos que originalmente o Gravity Sort foi pensado como uma implementação em hardware. Se o Gravity Sort é tão simples e intuitivo e tão bom em complexidade, por que ele não é amplamente usado, assim como o Quick Sort, por exemplo?</p></blockquote>

<p><strong>Dica</strong>: Observe a implementação apresentada em Python e tente ver qual complexidade o algoritmo fica implementando dessa forma para entradas particularmente grandes. Essa é uma complexidade linear?</p>

<hr/>

<p>Não continue até ser validado.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<blockquote><p>Fim do handout. Não fuja! Teremos um fechamento!</p></blockquote>

      </main>
      <footer>
        <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
          <img alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
        </a>
        © 2020 Desafios de Programação
      </footer>
    </div>
  </body>
</html>
