<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <title>Gravity Sort</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans+Extra+Condensed:700|Oxygen+Mono|Source+Sans+Pro:700|Source+Serif+Pro&display=swap">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/script.js"></script>
  </head>
  <body>
    <div class="container">
      <main>

<h1>Gravity Sort</h1>

<h2>De volta à Natureza</h2>

<p>Rozenberg desenhou o conceito que ficou conhecido como Computação Natural, que se trata de, a partir da observação de estruturas naturais, desenvolver estruturas computacionais.</p>

<p>O Gravity Sort faz parte de uma imensa gama de algoritmos com essas características, já que se baseia na força da gravidade para a sua concepção.</p>

<p>Ok, mas então vamos por fim apresentá-lo</p>

<p>Para entender a ideia podemos imaginar um caminhão carregado de caixa iguais, distribuídas em pilhas de diferentes alturas:</p>

<p class="figure"><img alt="caminhão" src="img/Novo-caminhão.png" title="caminhão" class="raster"/></p>

<p>Agora imagine que o caminhão está subindo uma ladeira e que essas caixas deslizam em seu interior</p>

<blockquote><p>PERGUNTA: Desenhe como ficarão as caixas nessa situação</p></blockquote>

<p>Ao terminar pode prosseguir</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p class="figure"><img alt="caminhão vetor" src="img/Novo-caminhão-2.png" title="caminhão vetor" class="raster"/></p>

<p>Sim, as caixas agora estão organizadas em pilhas crescentes, e adotaram essa composição depois de serem puxadas para traz pela gravidade...daí o nome Gravity Sort</p>

<p class="figure"><img alt="meme_genio" src="img/meme.jpg" title="meme_genio" class="raster"/></p>

<p>Da mesma forma, se o caminhão estiver descendo a ladeira, as caixas se organizariam de forma decrescente</p>

<p>Inicialmente esse algoritmo foi pensado para ser demonstrado com um <a href="https://pt.wikipedia.org/wiki/%C3%81baco" target="_blank">ábaco</a>, onde, em inglês, os discos que o compõe são chamados de “bead”, então esse algoritmo também pode ser encontrado como Bead Sort.</p>

<p>Mas enfim, como podemos traduzir essa movimentação que a gravidade proporciona para um código de ordenação?</p>

<h2>Implementação</h2>

<p>Primeiro precisamos de um caminhão...</p>

<p>...mas calma, você não precisa criar um caminhão do zero, nos damos ele para você:</p>

<p>Passo 1: Preenchendo o caminhão :</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort (input_list): 

        # A função recebe uma lista de entrada, 
        # onde cada valor da lista representa o número de 
        # caixas presentes em cada pilha.</code></pre>

<p>Passo 2: Primeiro loop -&gt; Inclinando o caminhão:</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort (input_list): 

    return_list = []
    transposed_list = [0] * max(input_list)

    # A partir da lista de entrada, se observarmos a
    # disposição das caixas a partir da trazeira do 
    # caminhão, temos uma lista que pode ser chama de
    # &quot;lista de acumulação&quot;, onde cada valor dessa 
    # lista é referente a disposição das caixas nesse 
    # novo ponto de vista.

    for num in input_list:
        for i in range(num):
            transposed_list[i] += 1
        print(num,transposed_list)</code></pre>

<blockquote><p>Escreva o lista de acumulação como descrito acima.</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p class="figure"><img alt="Vetor de acumulação" src="img/Novo-caminhão-3.png" title="Vetor de acumulação" class="raster"/></p>

<p>Você pode não ter notado, mas existe uma relação direta entre o maior valor existente na lista de entrada e o tamanho do vetor de acumulação...
ele são os mesmos, isso será importante quando discutirmos sobre complexidade. </p>

<p>Passo 3: Segundo loop -&gt; Contando as caixas:
A partir do vetor de acumulação, se retirar-mos uma caixa de cada pilha e as somar-mos temos um resultado interssante.</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort(input_list):

    print(&quot;Lista entrada&quot;)
    print(input_list)
    print(&quot;--------------------------------&quot;)

    return_list = []
    transposed_list = [0] * max(input_list)

    print(&quot;Loop 1&quot;)

    for num in input_list:
        for i in range(num):
            transposed_list[i] += 1
        print(num,transposed_list)


    print(&quot;--------------------------------&quot;)
    print(&quot;Loop 2&quot;)


    # Com a nova disposição de caixas da lista de acumulação,
    # o segundo loop é responsável por retirar uma caixa de 
    # cada uma das pilhas e somar a quantidade, guardando 
    # esse valor da soma em um vetor a ser retornado.</code></pre>

<blockquote><p>Implemente o segundo loop como descrito acima</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p>Com a implementação do segundo loop, já temos nosso código completo.</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort_traduzido(input_list):

    print(&quot;--------------------------------&quot;)

    return_list = []
    transposed_list = [0] * max(input_list)

    print(&quot;Loop 1&quot;)

    for num in input_list:
        for i in range(num):
            transposed_list[i] += 1

    print(&quot;--------------------------------&quot;)
    print(&quot;Loop 2&quot;)

    for _ in input_list:

        sum = 0
        for n in transposed_list:
            if(n &gt; 0): 
                sum += 1
        return_list.append(sum)

        for n,elem in enumerate(transposed_list):
            transposed_list[n] -= 1

return return_list</code></pre>

<p>Um detalhe interessante no segundo loop é o check de n &gt; 0, pode ter passado despercebido por alguns, então vale a pena observa-lo, esse chek so existe pois estamos trabalhando com um sistema inspirado no mundo físico, logo, quando n chega zero, significa que não há mais caixas na pilha. Apesar do loop continuar subtraindo uma caixa de cada andar, apenas os números positivos são considerados na contagem.</p>

<p>Mas afinal, qual é a saída desse algoritmo?</p>

<blockquote><p>Simule o resultado da return_lista com a entrada apresentada no exemplo inicial.</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p>~ Gif com o resultado aqui ~</p>

<p>Apesar de ser um algoritmo bem interessante, ele possui algumas limitações, que podem ser comparadas até com a sua inspiração do mundo real.</p>

<p>Da mesma forma que a caixa precisa ser dotada de massa para sofrer a ação da gravidade, o Gravity Sort necessita que os numeros de entrada sejam positivos.
Mas ainda assim é possível trabalhar com numeros negativos com esse algoritimo</p>

<blockquote><p>Você consegue pensar em um estratétgia para escapar dessa limitação?</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Complexidade</h2>

<p>Agora que temos a ideia do Gravity Sort, e sua implementação, podemos falar sobre a complexidade deste algoritmo.</p>

<blockquote><p>Discuta com seu grupo acerca da complexidade do Gravity Sort</p></blockquote>

<p>*Lembre-se da relação existente entre o vetor de entrada e o vetor de acumulação.</p>

<p>**Valide sua resposta</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p>Nessa implementação temos dois loops, vamos analisa-los separadamente:
O primeiro loop:</p>

<pre class="prettybox"><code class="prettyprint">for num in input_list:
        for i in range(num):
            transposed_list[i] += 1</code></pre>

<p>Esse tem seu número de execuções igual a soma de todos os valores na input list, podemos dizer que é um O(s), onde s representa essa soma de valores;</p>

<p>No segundo loop:</p>

<pre class="prettybox"><code class="prettyprint">for _ in input_list:

            sum = 0
            for n in transposed_list:
                if(n &gt; 0): 
                    sum += 1
            return_list.append(sum)

            for n,elem in enumerate(transposed_list):
                transposed_list[n] -= 1</code></pre>

<p>Temos esse loop, com outros dois loops dentro, vamos chama-los de loop a e loop b, respectivamente. O loop a tem uma complexidade O(n(max<em>num)), já que é executado a n vezes para o tamanho da transposed</em>list, que sabemos que é igual ao maior valor de entrada. Para o loop b temos um situação semelhante ao primeiro, em que é O(n(max<em>num)). Portanto para o segundo loop, temos uma complexidade O(2n*num</em>max).</p>

<p>Para o algoritmo completo temos uma complexidade igual a O(s+2n*max_num);</p>

<p>É possível, simplificar essa complexidade para O(n*max<em>num), já que a soma e a multiplicação de constantes não afetam o tempo de porcessamento. Porém não podemos desprezar o termo max</em>num, onde para uma entrada pequena com grandes valores, a lista de acumulação se torna automaticamente grande, o que eleva o tempo de processamento.</p>

<blockquote><p>Fim do handout. Não fuja! Teremos um fechamento!</p></blockquote>

      </main>
      <footer>
        <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
          <img alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
        </a>
        © 2020 Desafios de Programação
      </footer>
    </div>
  </body>
</html>
