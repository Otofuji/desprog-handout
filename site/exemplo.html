<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <title>Gravity Sort</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans+Extra+Condensed:700|Oxygen+Mono|Source+Sans+Pro:700|Source+Serif+Pro&display=swap">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/script.js"></script>
  </head>
  <body>
    <div class="container">
      <main>

<h1>Gravity Sort</h1>

<h2>De volta à Natureza</h2>

<p>Rozenberg desenhou o conceito que ficou conhecido como Computação Natural, que se trata de, a partir da observação de estruturas naturais, desenvolver estruturas computacionais.</p>

<p>O Gravity Sort faz parte de uma imensa gama de algoritmos com essas características, já que se baseia na força da gravidade para a sua concepção.</p>

<p>Ok, mas então vamos por fim apresentá-lo</p>

<p>Para entender a ideia podemos imaginar um caminhão carregado de caixa iguais, distribuídas em pilhas de diferentes alturas:</p>

<p class="figure"><img alt="caminhão" src="img/caminhão-2.png" title="caminhão" class="raster"/></p>

<p>Agora imagine que o caminhão está subindo uma ladeira e que essas caixas deslizam em seu interior</p>

<blockquote><p>PERGUNTA: Desenhe como ficarão as caixas nessa situação</p></blockquote>

<p>Ao terminar pode prosseguir</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p class="figure"><img alt="caminhão vetor" src="img/caminhão-3.png" title="caminhão vetor" class="raster"/></p>

<p>Sim, as caixas agora estão organizadas em pilhas crescentes, e adotaram essa composição depois de serem puxadas para traz pela gravidade...daí o nome Gravity Sort</p>

<p class="figure"><img alt="meme_genio" src="img/meme.jpg" title="meme_genio" class="raster"/></p>

<p>Da mesma forma, se o caminhão estiver descendo a ladeira, as caixas se organizariam de forma decrescente</p>

<p class="figure"><img alt="caminhão vetor" src="img/caminhão-4.png" title="caminhão vetor" class="raster"/></p>

<p>Inicialmente esse algoritmo foi pensado para ser demonstrado com um <a href="https://pt.wikipedia.org/wiki/%C3%81baco" target="_blank">ábaco</a>, onde, em inglês, os discos que o compõe são chamados de “bead”, então esse algoritmo também pode ser encontrado como Bead Sort.</p>

<p>Mas enfim, como podemos traduzir essa movimentação que a gravidade proporciona para um código de ordenação?</p>

<p>Primeiro precisamos de um caminhão...</p>

<p>...mas calma, você não precisa criar um caminhão do zero, nos damos ele para você:</p>

<p>Passo 1: Construir o caminhão com a altura correta 
    def gravity<em>sort (input</em>list): 
            # Podemos representar o caminhão como uma lista
            # Onde cada elemento da lista é uma “pilha” e
            # cada &quot;caixa&quot; é representado com uma unidade 
            # nesse elemento, iniciamos a lista com zero em cada 
            # elemento representando o caminhão vazio</p>

<p>Passo 2: Primeiro loop -&gt; Colocar as &quot;caixas&quot; no caminhão:
    def gravity<em>sort (input</em>list): </p>

<pre class="prettybox"><code class="prettyprint">    caminhao = [0] * max(input_list)
    return_list = []

    # Percorremos a lista de valores iniciais e para cada 
    # um deles fazemos um novo loop, nesse loop interno 
    # adicionamos 1 nas N primeiras posições da lista
    # isso funciona como empilhar as caixas da direita para
    # esquerda em cada uma das colunas.

    for num in input_list:
        for i in range(num):
            caminhao[i] += 1</code></pre>

<p>Passo 3: Para o passo 3, precisariamos &quot;girar o caminhão&quot;, mas isso não é prático computacionalmente (acredito que nem na vida real)</p>

<blockquote><p>Você consegue imaginar como &quot;girar&quot; esse caminhão?</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<p>A forma que encontramos não seria &quot;girar exatamente&quot;, computacionalmente, obtemos o resultado esperado fazendo a contagem ao retirar uma caixa da cada pilha, e colocando-o em um outra lista.
O valor resultante dessa contagem é igual ao maior elemento da lista.</p>

<p>Abaixo está o código da implementação completa:</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort (input_list): 

    caminhao = [0] * max(input_list)
    for num in input_list:
        for i in range(num):
            caminhao[i] += 1
    for j in input_list:
        sum = 0
    for n in transposed_list:
        if(n &gt; 0):
            sum += 1
    return_list.append(sum)
    for n,elem in enumerate(transposed_list):
        transposedlist[n] -= 1
    print(&quot;return&quot;,,returnlist)
    print(&quot;Transposed&quot;,,transposed_list)

return return_list</code></pre>

<p>Apesar de ser um algoritmo bem interessante, ele possui algumas limitações, que podem ser comparadas até com a sua inspiração do mundo real.</p>

<p>Da mesma forma que a caixa precisa ser dotada de massa para sofrer a ação da gravidade, o Gravity Sort necessita que os numeros de entrada sejam positivos.
Mas ainda assim é possível trabalhar com numeros negativos com esse algoritimo</p>

<blockquote><p>Você consegue pensar em um estratétgia para escapar dessa limitação?</p></blockquote>

<p>**Valide sua resporta</p>

<blockquote><p>Fim do handout. Não fuja! Teremos um fechamento!</p></blockquote>

      </main>
      <footer>
        <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
          <img alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
        </a>
        © 2020 Desafios de Programação
      </footer>
    </div>
  </body>
</html>
