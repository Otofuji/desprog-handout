<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <title>Gravity Sort</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans+Extra+Condensed:700|Oxygen+Mono|Source+Sans+Pro:700|Source+Serif+Pro&display=swap">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/script.js"></script>
  </head>
  <body>
    <div class="container">
      <main>

<h1>Gravity Sort</h1>

<h2>De volta à Natureza</h2>

<p>Rozenberg desenhou o conceito que ficou conhecido como Computação Natural, que se trata de, a partir da observação de estruturas naturais, desenvolver estruturas computacionais.</p>

<p>O Gravity Sort faz parte de uma imensa gama de algoritmos com essas características, já que se baseia na força da gravidade para a sua concepção. Vamos por fim apresentá-lo.</p>

<p>Para entender a ideia podemos imaginar um caminhão carregado de caixa iguais, distribuídas em pilhas de diferentes alturas:</p>

<p class="figure"><img alt="caminhão" src="img/Novo-caminhão.png" title="caminhão" class="raster"/></p>

<p>Agora imagine que o caminhão está subindo uma ladeira e que essas caixas deslizam em seu interior</p>

<blockquote><p>PERGUNTA: Desenhe como ficarão as caixas nessa situação</p></blockquote>

<p>Ao terminar pode prosseguir.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>A gravidade funciona</h2>

<p class="figure"><img alt="caminhão vetor" src="img/Novo-caminhão-2.png" title="caminhão vetor" class="raster"/></p>

<p>Sim, as caixas agora estão organizadas em pilhas crescentes, e adotaram essa composição depois de serem puxadas para trás pela gravidade… <strong>daí o nome Gravity Sort!</strong></p>

<p class="figure"><img alt="meme_genio" src="img/meme.jpg" title="meme_genio" class="raster"/></p>

<p>Da mesma forma, se o caminhão estiver descendo a ladeira, as caixas se organizariam de forma decrescente.</p>

<p>Inicialmente, esse algoritmo foi pensado para ser demonstrado com um <a href="https://pt.wikipedia.org/wiki/%C3%81baco" target="_blank">ábaco</a>, onde, em inglês, os discos que o compõe são chamados de “bead”. Por isso, este mesmo algoritmo também pode ser chamado de Bead Sort.</p>

<p>Mas enfim, como podemos traduzir essa movimentação que a gravidade proporciona para um código de ordenação?</p>

<p>Antes de pensar na implementação, vamos pensar em como podemos transmutar essa analogia das caixas do caminhão. </p>

<p>Talvez as imagens dos caminhões que apareceram antes contenham algum spoiler que te ajude a pensar.</p>

<blockquote><p>PERGUNTA: pensando em vetores, o que são são os índices do vetor e o que são os valores em cada caixa?</p></blockquote>

<p>Valide a resposta antes de prosseguir.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Implementação</h2>

<p>Primeiro precisamos de um caminhão…</p>

<p>…mas calma, você não precisa criar um caminhão do zero. Nós damos ele para você:</p>

<p>Passo 1: Preenchendo o caminhão:</p>

<p>A função recebe uma lista de entrada, onde cada valor da lista representa o número de caixas presente em cada pilha. </p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort (input_list): </code></pre>

<p>Passo 2: Primeiro loop -&gt; Inclinando o caminhão:</p>

<p>A partir da lista de entrada, se observarmos a disposição das caixas a partir da traseira do caminhão, temos uma lista que pode ser chamada de &quot;lista de acumulação&quot;, onde cada valor dessa lista é referente à disposição das caixas nesse novo ponto de vista.</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort (input_list): 

    return_list = []
    transposed_list = [0] * max(input_list)

    for num in input_list:
        for i in range(num):
            transposed_list[i] += 1
        print(num,transposed_list)</code></pre>

<blockquote><p>PERGUNTA: o que está acontecendo com o caminhão na lista de acumulação?</p></blockquote>

<p>Valide a resposta antes de prosseguir.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Vetor de acumulação</h2>

<p class="figure"><img alt="Vetor de acumulação" src="img/Novo-caminhão-3.png" title="Vetor de acumulação" class="raster"/></p>

<p>Você pode não ter notado, mas existe uma relação direta entre o maior valor existente na lista de entrada e o tamanho do vetor de acumulação… eles são os mesmos! Isso será importante quando discutirmos sobre complexidade. </p>

<p>Vamos continuar com os passos.</p>

<p>Passo 3: Segundo loop -&gt; Contando as caixas:</p>

<p>A partir do vetor de acumulação, se retirarmos uma caixa de cada pilha e as somarmos temos um resultado interssante.</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort(input_list):

    print(&quot;Lista entrada&quot;)
    print(input_list)
    print(&quot;--------------------------------&quot;)

    return_list = []
    transposed_list = [0] * max(input_list)

    print(&quot;Loop 1&quot;)

    for num in input_list:
        for i in range(num):
            transposed_list[i] += 1
        print(num,transposed_list)


    print(&quot;--------------------------------&quot;)
    print(&quot;Loop 2&quot;)</code></pre>

<p>Com a nova disposição de caixas da lista de acumulação, o segundo loop é responsável por retirar uma caixa de cada uma das pilhas e somar a quantidade, guardando esse valor da soma em um vetor a ser retornado.</p>

<blockquote><p>Implemente o segundo loop como descrito acima.</p></blockquote>

<p>Valide a resposta antes de prosseguir. Peça ajuda se travar. </p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Habemus Gravity Sort</h2>

<p>Com a implementação do segundo loop, já temos nosso código completo.</p>

<pre class="prettybox"><code class="prettyprint">def gravity_sort_traduzido(input_list):

    print(&quot;--------------------------------&quot;)

    return_list = []
    transposed_list = [0] * max(input_list)

    print(&quot;Loop 1&quot;)

    for num in input_list:
        for i in range(num):
            transposed_list[i] += 1

    print(&quot;--------------------------------&quot;)
    print(&quot;Loop 2&quot;)

    for _ in input_list:

        sum = 0
        for n in transposed_list:
            if(n &gt; 0): 
                sum += 1
        return_list.append(sum)

        for n,elem in enumerate(transposed_list):
            transposed_list[n] -= 1

return return_list</code></pre>

<p>Um detalhe interessante no segundo loop é o check de <code class="prettybox prettyprint">n &gt; 0</code>, que pode ter passado despercebido por alguns. Essa verificação só existe porque estamos trabalhando com um sistema inspirado no mundo físico. Logo, quando <code class="prettybox prettyprint">n</code> chega zero, significa que não há mais caixas na pilha. Apesar do loop continuar subtraindo uma caixa de cada andar, apenas os números positivos são considerados na contagem.</p>

<p>Mas, afinal, qual é a saída desse algoritmo?</p>

<blockquote><p>Simule o resultado da return_lista com a entrada apresentada no exemplo inicial.</p></blockquote>

<p>Valide a resposta antes de prosseguir.</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Vamos para os finalmente: output</h2>

<p>~ Gif com o resultado aqui ~</p>

<p>Apesar de ser um algoritmo bem interessante, ele possui algumas limitações, que podem ser comparadas até com a sua inspiração do mundo real.</p>

<p>Da mesma forma que a caixa precisa ser dotada de massa para sofrer a ação da gravidade, o Gravity Sort necessita que os numeros de entrada sejam positivos. Mas ainda assim é possível trabalhar com numeros negativos com esse algoritimo</p>

<blockquote><p>Você consegue pensar em um estratégia para escapar dessa limitação?</p></blockquote>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Complexo?</h2>

<p>Agora que temos a ideia do Gravity Sort, e sua implementação, podemos falar sobre a complexidade deste algoritmo.</p>

<blockquote><p>Discuta com seu grupo acerca da complexidade do Gravity Sort</p></blockquote>

<p>*Lembre-se da relação existente entre o vetor de entrada e o vetor de acumulação.</p>

<p>**Valide sua resposta</p>

<h3><a href="">continuar</a> ou <a href="">terminar</a></h3>

<h2>Complexidade do Gravity Sort</h2>

<p>Nessa implementação, temos dois loops. Vamos analisá-los separadamente:</p>

<p>O primeiro loop:</p>

<pre class="prettybox"><code class="prettyprint">for num in input_list:
        for i in range(num):
            transposed_list[i] += 1</code></pre>

<p>Esse tem seu número de execuções igual à soma de todos os valores na input list. Podemos dizer que é um <code class="prettybox prettyprint">O(s)</code>, onde <code class="prettybox prettyprint">s</code> representa essa soma de valores;</p>

<p>No segundo loop:</p>

<pre class="prettybox"><code class="prettyprint">for _ in input_list:

            sum = 0
            for n in transposed_list:
                if(n &gt; 0): 
                    sum += 1
            return_list.append(sum)

            for n,elem in enumerate(transposed_list):
                transposed_list[n] -= 1</code></pre>

<p>Temos esse loop, com outros dois loops dentro. Vamos chamá-los de <code class="prettybox prettyprint">loop a</code> e <code class="prettybox prettyprint">loop b</code>, respectivamente. O <code class="prettybox prettyprint">loop a</code> tem uma complexidade <code class="prettybox prettyprint">O(n(max_num))</code>, já que é executado a <code class="prettybox prettyprint">n</code> vezes para o tamanho da <code class="prettybox prettyprint">transposed_list</code>, que sabemos que é igual ao maior valor de entrada. Para o <code class="prettybox prettyprint">loop b</code>, temos um situação semelhante ao primeiro, em que é <code class="prettybox prettyprint">O(n(max_num))</code>. Portanto, para o segundo loop, temos uma complexidade <code class="prettybox prettyprint">O(2n*num_max)</code>.</p>

<p>Para o algoritmo completo temos uma complexidade igual a <code class="prettybox prettyprint">O(s+2n*max_num)</code>.</p>

<p>É possível simplificar essa complexidade para <code class="prettybox prettyprint">O(n*max_num)</code>, já que a soma e a multiplicação de constantes não afetam o tempo de processamento. Porém não podemos desprezar o termo <code class="prettybox prettyprint">max_num</code>, onde para uma entrada pequena com grandes valores, a lista de acumulação se torna automaticamente grande, o que eleva o tempo de processamento.</p>

<blockquote><p>Fim do handout.</p></blockquote>

      </main>
      <footer>
        <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
          <img alt="Creative Commons Attribution-ShareAlike 4.0 International License" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
        </a>
        © 2020 Desafios de Programação
      </footer>
    </div>
  </body>
</html>
